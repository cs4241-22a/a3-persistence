const path = require('path')
const mongodb = require('mongodb')
//require('dotenv').config()
const passport = require('passport')
const GitHubStrategy = require('passport-github2')
const session = require('express-session');
const express = require('express'),
  app = express()
const connectEnsureLogin = require('connect-ensure-login');
const bodyParser = require('body-parser'); // middleware for parsing body
const User = require('./model/users.js')
const Tasks = require('./model/tasks.js')
const LocalStrategy = require('passport-local').Strategy;
const ObjectId = require('mongodb').ObjectId

const RES_OK = 200, RES_BAD_REQUEST = 400, RES_USER_EXISTS = 402, RES_TASK_ERR = 410

//npx tailwindcss -i ./public/css/tailwindStyle.css -o ./public/css/output.css --watch

app.use(bodyParser.urlencoded({ extended: true }));

app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: true,
  cookie: { maxAge: 3600000 }
}));

// Middlewares


app.use(passport.initialize());
app.use(passport.session());

// Local strategy generated by passport-local-mongoose
passport.use(new LocalStrategy(User.authenticate()))

// github strategy for oauth connection
passport.use(new GitHubStrategy({
  clientID: process.env.CLIENT_ID,
  clientSecret: process.env.CLIENT_SECRET,
  callbackURL: "https://a3-siddhartha-pradhan.glitch.me/auth/github/callback"
},
  function (accessToken, refreshToken, profile, done) {
    process.nextTick(function () {
      User.findByUsername(profile.username).exec().then(user => {
        if (!user) {
          // no user with this username, create one
          User.register({ username: profile.username }, profile.id, (err, account) => {
            if (err) {
              console.log(err)
            } else {
              done(null, account)
            }
          })
        } else {
          done(null, user)
        }
      })
    })
  }
));

// Session Management
passport.serializeUser(User.serializeUser());
passport.deserializeUser(User.deserializeUser());

app.get('/auth/github/callback', 
  passport.authenticate('github', { failureRedirect: '/login', failureMessage:true }),
  function (req, res) {
    console.log("AUTHENTICATION: Github account")
    res.redirect('/index');
  });

// Github authentication
app.get('/auth/github',
  passport.authenticate('github', { scope: ['user:email'] }),
  function (req, res) { });






// handle login attempt
app.post('/login', passport.authenticate('local', { failureRedirect: '/login', failureMessage:true}), function (req, res) {
  console.log("AUTHENTICATION: Local account")
  res.redirect('/index');
});
// handle login attempt
// app.post('/login', function (req, res, next) {
//   passport.authenticate('local', function(err, user, info) {
//     console.log(err,user,info)
//     if (err){
//       return next(err)
//     }
//     if (!user){
//       return res.status(401).send({ success : false, message : "Authentication unsuccessful" })

//     } else {
//       req.logIn(user,function(err){
//         if (err){
//           console.log(err)
//         } else {
//           return res.redirect('/index');

//         }
//       })
//     }
//   })
// })
    
//     //console.log("AUTHENTICATION: Local account")
//     //res.redirect('/index');
//   })(req, res, next);

// });


// local mongoose db
app.get("/", function (req, res) {
  if (req.isAuthenticated()) {
    res.sendFile(__dirname + '/public/index.html')
  } else {
    res.sendFile(__dirname + '/public/login.html');
  }

});

app.get('/index', connectEnsureLogin.ensureLoggedIn(), (req, res) => {
  res.sendFile(__dirname + '/public/index.html');
});


app.get("/login", function (req, res) {
  res.sendFile(__dirname + "/public/login.html")
});


app.get('/logout', function (req, res, next) {
  req.logout(function(err) {
    if (err) { return next(err); }
    res.redirect('/');
  });
});

app.get("/username",connectEnsureLogin.ensureLoggedIn(), function (req, res) {
  res.writeHeader(200, { 'Content-Type': 'application/json' })
  res.end(JSON.stringify({username:req.user.username}))
});






// get tasks for an authenticated user
app.get('/tasks', connectEnsureLogin.ensureLoggedIn(), function (req, res) {
  console.log("Tasks request for: " + req.user.username)
  User.findByUsername(req.user.username).exec().then(user => {
    Tasks.find({ userId: user._id }).exec().then(tasks => {
      //console.log(tasks)
      res.writeHeader(200, { 'Content-Type': 'application/json' })
      res.end(JSON.stringify(tasks))
    })
  })
});


// post request for adding a task for an authenticated user
app.post('/tasks/add', connectEnsureLogin.ensureLoggedIn(), bodyParser.json({ extended: true}),function (req, res) {
  console.log("Add request for: " + req.user.username)
  const incomingData = req.body
  var currentDateTime = Date.now();
  if (incomingData.dueDate == null) {
    incomingData.taskUrgency = null;
  } else {
    if (currentDateTime > incomingData.dueDate) currentDateTime = incomingData.dueDate;
    incomingData.taskUrgency = getTaskUrgency(incomingData.dueDate - currentDateTime);
  }
  incomingData.taskCreationTime = currentDateTime;
  User.findByUsername(req.user.username).exec().then(user => {
    incomingData.userId = user._id
    const taskToAdd = new Tasks(incomingData)
    taskToAdd.save(function (err) {
      if (err) {
        res.writeHead(RES_TASK_ERR, "Cannot add the sent task", { 'Content-Type': 'text/plain' })
        res.end()
      } else {
        res.writeHead(200, "OK", { 'Content-Type': 'text/plain' })
        res.end()

      }
    })
  })
})



// deltaTime in ms
// Urgency is either 0(past due), 1 (URGENT), 2(medium urgency), 3 (not really)
const getTaskUrgency = function (deltaTime) {
  const numDaysLeft = deltaTime / 86400000;
  //console.log("Days left " + numDaysLeft);
  if (numDaysLeft <= 0) {
    return 0;
  } else if (numDaysLeft <= 2) {
    return 1;
  } else if (numDaysLeft <= 7) {
    return 2;
  } else {
    return 3;
  }
}


// post request for deleting a task for an authenticated user
app.post('/tasks/delete', connectEnsureLogin.ensureLoggedIn(), bodyParser.json({ extended: true}), function (req, res) {
  console.log("Delete request for: " + req.user.username)
  const incomingData = req.body
  User.findByUsername(req.user.username).exec().then(user => {
    Tasks.deleteOne({ userId: user._id, _id: ObjectId(incomingData.taskID) }, function (err) {
      if (err) {
        res.writeHead(RES_TASK_ERR, err.message, { 'Content-Type': 'text/plain' })
        res.end()
      } else {
        res.writeHead(200, { 'Content-Type': 'application/json' })
        res.end()
      }
    })
  })
})

// post request for editing a task for an authenticated user
app.post('/tasks/edit', connectEnsureLogin.ensureLoggedIn(), bodyParser.json({ extended: true}), function (req, res) {
  console.log("Edit request for: " + req.user.username)
  const incomingData = req.body
  var currentDateTime = incomingData.taskCreationTime;
  if (incomingData.dueDate == null) {
    incomingData.taskUrgency = null;
  } else {
    if (currentDateTime > incomingData.dueDate) currentDateTime = incomingData.dueDate;
    incomingData.taskUrgency = getTaskUrgency(Number(incomingData.dueDate) - Number(currentDateTime));
  }
  incomingData.taskCreationTime = currentDateTime;
  User.findByUsername(req.user.username).exec().then(user => {
    incomingData.userId = user._id // should be same, still updating just in case
    const editedTask = new Tasks(incomingData)
    Tasks.findOneAndUpdate({ _id: incomingData._id, userId: incomingData.userId }, editedTask, function (err) {
      if (err) {
        res.writeHead(RES_TASK_ERR, "Gone", { 'Content-Type': 'text/plain' })
        res.end()
      } else {
        res.writeHead(RES_OK, "OK", { 'Content-Type': 'text/plain' })
        res.end()
      }
    })
  })


})


app.get('/user/register',function (req, res) {
  res.sendFile(__dirname + "/public/register.html")
})


app.post('/user/register', function (req, res) {
  var username = req.body.username
  var password = req.body.password
  User.findByUsername(username).exec().then(user => {
    if (user == null){
      User.register({username:username},password)
      res.redirect('/login')
    } else {
      res.writeHead(RES_USER_EXISTS, "Username already exists", { 'Content-Type': 'text/plain' })
      res.end()
    }
  })
  

})


// serve rest of the files, has to be in the bottomish
app.use(express.static("./public/"));

app.listen(process.env.PORT || 3000)
console.log("Server started")
